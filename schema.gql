# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type Account {
  access_token: String
  expires_at: Int
  id: String!
  id_token: String
  provider: String!
  providerAccountId: String!
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String!
  user: User!
  userId: String!
}

type AccountAvgAggregate {
  expires_at: Float
}

input AccountAvgOrderByAggregateInput {
  expires_at: SortOrder
}

type AccountCountAggregate {
  _all: Int!
  access_token: Int!
  expires_at: Int!
  id: Int!
  id_token: Int!
  provider: Int!
  providerAccountId: Int!
  refresh_token: Int!
  scope: Int!
  session_state: Int!
  token_type: Int!
  type: Int!
  userId: Int!
}

input AccountCountOrderByAggregateInput {
  access_token: SortOrder
  expires_at: SortOrder
  id: SortOrder
  id_token: SortOrder
  provider: SortOrder
  providerAccountId: SortOrder
  refresh_token: SortOrder
  scope: SortOrder
  session_state: SortOrder
  token_type: SortOrder
  type: SortOrder
  userId: SortOrder
}

input AccountCreateInput {
  access_token: String
  expires_at: Int
  id: String
  id_token: String
  provider: String!
  providerAccountId: String!
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String!
  user: UserCreateNestedOneWithoutAccountsInput!
}

input AccountCreateManyInput {
  access_token: String
  expires_at: Int
  id: String
  id_token: String
  provider: String!
  providerAccountId: String!
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String!
  userId: String!
}

input AccountCreateManyUserInput {
  access_token: String
  expires_at: Int
  id: String
  id_token: String
  provider: String!
  providerAccountId: String!
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String!
}

input AccountCreateManyUserInputEnvelope {
  data: [AccountCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input AccountCreateNestedManyWithoutUserInput {
  connect: [AccountWhereUniqueInput!]
  connectOrCreate: [AccountCreateOrConnectWithoutUserInput!]
  create: [AccountCreateWithoutUserInput!]
  createMany: AccountCreateManyUserInputEnvelope
}

input AccountCreateOrConnectWithoutUserInput {
  create: AccountCreateWithoutUserInput!
  where: AccountWhereUniqueInput!
}

input AccountCreateWithoutUserInput {
  access_token: String
  expires_at: Int
  id: String
  id_token: String
  provider: String!
  providerAccountId: String!
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String!
}

type AccountGroupBy {
  _avg: AccountAvgAggregate
  _count: AccountCountAggregate
  _max: AccountMaxAggregate
  _min: AccountMinAggregate
  _sum: AccountSumAggregate
  access_token: String
  expires_at: Int
  id: String!
  id_token: String
  provider: String!
  providerAccountId: String!
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String!
  userId: String!
}

input AccountListRelationFilter {
  every: AccountWhereInput
  none: AccountWhereInput
  some: AccountWhereInput
}

type AccountMaxAggregate {
  access_token: String
  expires_at: Int
  id: String
  id_token: String
  provider: String
  providerAccountId: String
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String
  userId: String
}

input AccountMaxOrderByAggregateInput {
  access_token: SortOrder
  expires_at: SortOrder
  id: SortOrder
  id_token: SortOrder
  provider: SortOrder
  providerAccountId: SortOrder
  refresh_token: SortOrder
  scope: SortOrder
  session_state: SortOrder
  token_type: SortOrder
  type: SortOrder
  userId: SortOrder
}

type AccountMinAggregate {
  access_token: String
  expires_at: Int
  id: String
  id_token: String
  provider: String
  providerAccountId: String
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String
  userId: String
}

input AccountMinOrderByAggregateInput {
  access_token: SortOrder
  expires_at: SortOrder
  id: SortOrder
  id_token: SortOrder
  provider: SortOrder
  providerAccountId: SortOrder
  refresh_token: SortOrder
  scope: SortOrder
  session_state: SortOrder
  token_type: SortOrder
  type: SortOrder
  userId: SortOrder
}

input AccountOrderByRelationAggregateInput {
  _count: SortOrder
}

input AccountOrderByWithAggregationInput {
  _avg: AccountAvgOrderByAggregateInput
  _count: AccountCountOrderByAggregateInput
  _max: AccountMaxOrderByAggregateInput
  _min: AccountMinOrderByAggregateInput
  _sum: AccountSumOrderByAggregateInput
  access_token: SortOrder
  expires_at: SortOrder
  id: SortOrder
  id_token: SortOrder
  provider: SortOrder
  providerAccountId: SortOrder
  refresh_token: SortOrder
  scope: SortOrder
  session_state: SortOrder
  token_type: SortOrder
  type: SortOrder
  userId: SortOrder
}

input AccountOrderByWithRelationInput {
  access_token: SortOrder
  expires_at: SortOrder
  id: SortOrder
  id_token: SortOrder
  provider: SortOrder
  providerAccountId: SortOrder
  refresh_token: SortOrder
  scope: SortOrder
  session_state: SortOrder
  token_type: SortOrder
  type: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

input AccountProviderProviderAccountIdCompoundUniqueInput {
  provider: String!
  providerAccountId: String!
}

enum AccountScalarFieldEnum {
  access_token
  expires_at
  id
  id_token
  provider
  providerAccountId
  refresh_token
  scope
  session_state
  token_type
  type
  userId
}

input AccountScalarWhereInput {
  AND: [AccountScalarWhereInput!]
  NOT: [AccountScalarWhereInput!]
  OR: [AccountScalarWhereInput!]
  access_token: StringNullableFilter
  expires_at: IntNullableFilter
  id: StringFilter
  id_token: StringNullableFilter
  provider: StringFilter
  providerAccountId: StringFilter
  refresh_token: StringNullableFilter
  scope: StringNullableFilter
  session_state: StringNullableFilter
  token_type: StringNullableFilter
  type: StringFilter
  userId: StringFilter
}

input AccountScalarWhereWithAggregatesInput {
  AND: [AccountScalarWhereWithAggregatesInput!]
  NOT: [AccountScalarWhereWithAggregatesInput!]
  OR: [AccountScalarWhereWithAggregatesInput!]
  access_token: StringNullableWithAggregatesFilter
  expires_at: IntNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  id_token: StringNullableWithAggregatesFilter
  provider: StringWithAggregatesFilter
  providerAccountId: StringWithAggregatesFilter
  refresh_token: StringNullableWithAggregatesFilter
  scope: StringNullableWithAggregatesFilter
  session_state: StringNullableWithAggregatesFilter
  token_type: StringNullableWithAggregatesFilter
  type: StringWithAggregatesFilter
  userId: StringWithAggregatesFilter
}

type AccountSumAggregate {
  expires_at: Int
}

input AccountSumOrderByAggregateInput {
  expires_at: SortOrder
}

input AccountUpdateInput {
  access_token: NullableStringFieldUpdateOperationsInput
  expires_at: NullableIntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  id_token: NullableStringFieldUpdateOperationsInput
  provider: StringFieldUpdateOperationsInput
  providerAccountId: StringFieldUpdateOperationsInput
  refresh_token: NullableStringFieldUpdateOperationsInput
  scope: NullableStringFieldUpdateOperationsInput
  session_state: NullableStringFieldUpdateOperationsInput
  token_type: NullableStringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutAccountsNestedInput
}

input AccountUpdateManyMutationInput {
  access_token: NullableStringFieldUpdateOperationsInput
  expires_at: NullableIntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  id_token: NullableStringFieldUpdateOperationsInput
  provider: StringFieldUpdateOperationsInput
  providerAccountId: StringFieldUpdateOperationsInput
  refresh_token: NullableStringFieldUpdateOperationsInput
  scope: NullableStringFieldUpdateOperationsInput
  session_state: NullableStringFieldUpdateOperationsInput
  token_type: NullableStringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
}

input AccountUpdateManyWithWhereWithoutUserInput {
  data: AccountUpdateManyMutationInput!
  where: AccountScalarWhereInput!
}

input AccountUpdateManyWithoutUserNestedInput {
  connect: [AccountWhereUniqueInput!]
  connectOrCreate: [AccountCreateOrConnectWithoutUserInput!]
  create: [AccountCreateWithoutUserInput!]
  createMany: AccountCreateManyUserInputEnvelope
  delete: [AccountWhereUniqueInput!]
  deleteMany: [AccountScalarWhereInput!]
  disconnect: [AccountWhereUniqueInput!]
  set: [AccountWhereUniqueInput!]
  update: [AccountUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [AccountUpdateManyWithWhereWithoutUserInput!]
  upsert: [AccountUpsertWithWhereUniqueWithoutUserInput!]
}

input AccountUpdateWithWhereUniqueWithoutUserInput {
  data: AccountUpdateWithoutUserInput!
  where: AccountWhereUniqueInput!
}

input AccountUpdateWithoutUserInput {
  access_token: NullableStringFieldUpdateOperationsInput
  expires_at: NullableIntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  id_token: NullableStringFieldUpdateOperationsInput
  provider: StringFieldUpdateOperationsInput
  providerAccountId: StringFieldUpdateOperationsInput
  refresh_token: NullableStringFieldUpdateOperationsInput
  scope: NullableStringFieldUpdateOperationsInput
  session_state: NullableStringFieldUpdateOperationsInput
  token_type: NullableStringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
}

input AccountUpsertWithWhereUniqueWithoutUserInput {
  create: AccountCreateWithoutUserInput!
  update: AccountUpdateWithoutUserInput!
  where: AccountWhereUniqueInput!
}

input AccountWhereInput {
  AND: [AccountWhereInput!]
  NOT: [AccountWhereInput!]
  OR: [AccountWhereInput!]
  access_token: StringNullableFilter
  expires_at: IntNullableFilter
  id: StringFilter
  id_token: StringNullableFilter
  provider: StringFilter
  providerAccountId: StringFilter
  refresh_token: StringNullableFilter
  scope: StringNullableFilter
  session_state: StringNullableFilter
  token_type: StringNullableFilter
  type: StringFilter
  user: UserRelationFilter
  userId: StringFilter
}

input AccountWhereUniqueInput {
  id: String
  provider_providerAccountId: AccountProviderProviderAccountIdCompoundUniqueInput
}

type AffectedRowsOutput {
  count: Int!
}

type AggregateAccount {
  _avg: AccountAvgAggregate
  _count: AccountCountAggregate
  _max: AccountMaxAggregate
  _min: AccountMinAggregate
  _sum: AccountSumAggregate
}

type AggregateContestant {
  _avg: ContestantAvgAggregate
  _count: ContestantCountAggregate
  _max: ContestantMaxAggregate
  _min: ContestantMinAggregate
  _sum: ContestantSumAggregate
}

type AggregateEvent {
  _count: EventCountAggregate
  _max: EventMaxAggregate
  _min: EventMinAggregate
}

type AggregateSession {
  _count: SessionCountAggregate
  _max: SessionMaxAggregate
  _min: SessionMinAggregate
}

type AggregateUser {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
}

type AggregateVerificationToken {
  _count: VerificationTokenCountAggregate
  _max: VerificationTokenMaxAggregate
  _min: VerificationTokenMinAggregate
}

type Contestant {
  age: Int!
  birthDate: String
  createdAt: DateTime
  email: String!
  event: Event!
  eventId: String!
  firstName: String!
  gender: String!
  id: String!
  lastName: String!
  middleName: String
  nationality: String
  phoneNumber: String!
  photo: String
  updatedAt: DateTime
  user: User!
  userId: String!
}

type ContestantAvgAggregate {
  age: Float
}

input ContestantAvgOrderByAggregateInput {
  age: SortOrder
}

type ContestantCountAggregate {
  _all: Int!
  age: Int!
  birthDate: Int!
  createdAt: Int!
  email: Int!
  eventId: Int!
  firstName: Int!
  gender: Int!
  id: Int!
  lastName: Int!
  middleName: Int!
  nationality: Int!
  phoneNumber: Int!
  photo: Int!
  updatedAt: Int!
  userId: Int!
}

input ContestantCountOrderByAggregateInput {
  age: SortOrder
  birthDate: SortOrder
  createdAt: SortOrder
  email: SortOrder
  eventId: SortOrder
  firstName: SortOrder
  gender: SortOrder
  id: SortOrder
  lastName: SortOrder
  middleName: SortOrder
  nationality: SortOrder
  phoneNumber: SortOrder
  photo: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input ContestantCreateInput {
  age: Int!
  birthDate: String
  createdAt: DateTime
  email: String!
  event: EventCreateNestedOneWithoutContestantsInput!
  firstName: String!
  gender: String!
  id: String
  lastName: String!
  middleName: String
  nationality: String
  phoneNumber: String!
  photo: String
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutContestantInput!
}

input ContestantCreateManyEventInput {
  age: Int!
  birthDate: String
  createdAt: DateTime
  email: String!
  firstName: String!
  gender: String!
  id: String
  lastName: String!
  middleName: String
  nationality: String
  phoneNumber: String!
  photo: String
  updatedAt: DateTime
  userId: String!
}

input ContestantCreateManyEventInputEnvelope {
  data: [ContestantCreateManyEventInput!]!
  skipDuplicates: Boolean
}

input ContestantCreateManyInput {
  age: Int!
  birthDate: String
  createdAt: DateTime
  email: String!
  eventId: String!
  firstName: String!
  gender: String!
  id: String
  lastName: String!
  middleName: String
  nationality: String
  phoneNumber: String!
  photo: String
  updatedAt: DateTime
  userId: String!
}

input ContestantCreateManyUserInput {
  age: Int!
  birthDate: String
  createdAt: DateTime
  email: String!
  eventId: String!
  firstName: String!
  gender: String!
  id: String
  lastName: String!
  middleName: String
  nationality: String
  phoneNumber: String!
  photo: String
  updatedAt: DateTime
}

input ContestantCreateManyUserInputEnvelope {
  data: [ContestantCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input ContestantCreateNestedManyWithoutEventInput {
  connect: [ContestantWhereUniqueInput!]
  connectOrCreate: [ContestantCreateOrConnectWithoutEventInput!]
  create: [ContestantCreateWithoutEventInput!]
  createMany: ContestantCreateManyEventInputEnvelope
}

input ContestantCreateNestedManyWithoutUserInput {
  connect: [ContestantWhereUniqueInput!]
  connectOrCreate: [ContestantCreateOrConnectWithoutUserInput!]
  create: [ContestantCreateWithoutUserInput!]
  createMany: ContestantCreateManyUserInputEnvelope
}

input ContestantCreateOrConnectWithoutEventInput {
  create: ContestantCreateWithoutEventInput!
  where: ContestantWhereUniqueInput!
}

input ContestantCreateOrConnectWithoutUserInput {
  create: ContestantCreateWithoutUserInput!
  where: ContestantWhereUniqueInput!
}

input ContestantCreateWithoutEventInput {
  age: Int!
  birthDate: String
  createdAt: DateTime
  email: String!
  firstName: String!
  gender: String!
  id: String
  lastName: String!
  middleName: String
  nationality: String
  phoneNumber: String!
  photo: String
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutContestantInput!
}

input ContestantCreateWithoutUserInput {
  age: Int!
  birthDate: String
  createdAt: DateTime
  email: String!
  event: EventCreateNestedOneWithoutContestantsInput!
  firstName: String!
  gender: String!
  id: String
  lastName: String!
  middleName: String
  nationality: String
  phoneNumber: String!
  photo: String
  updatedAt: DateTime
}

type ContestantGroupBy {
  _avg: ContestantAvgAggregate
  _count: ContestantCountAggregate
  _max: ContestantMaxAggregate
  _min: ContestantMinAggregate
  _sum: ContestantSumAggregate
  age: Int!
  birthDate: String
  createdAt: DateTime
  email: String!
  eventId: String!
  firstName: String!
  gender: String!
  id: String!
  lastName: String!
  middleName: String
  nationality: String
  phoneNumber: String!
  photo: String
  updatedAt: DateTime
  userId: String!
}

input ContestantListRelationFilter {
  every: ContestantWhereInput
  none: ContestantWhereInput
  some: ContestantWhereInput
}

type ContestantMaxAggregate {
  age: Int
  birthDate: String
  createdAt: DateTime
  email: String
  eventId: String
  firstName: String
  gender: String
  id: String
  lastName: String
  middleName: String
  nationality: String
  phoneNumber: String
  photo: String
  updatedAt: DateTime
  userId: String
}

input ContestantMaxOrderByAggregateInput {
  age: SortOrder
  birthDate: SortOrder
  createdAt: SortOrder
  email: SortOrder
  eventId: SortOrder
  firstName: SortOrder
  gender: SortOrder
  id: SortOrder
  lastName: SortOrder
  middleName: SortOrder
  nationality: SortOrder
  phoneNumber: SortOrder
  photo: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

type ContestantMinAggregate {
  age: Int
  birthDate: String
  createdAt: DateTime
  email: String
  eventId: String
  firstName: String
  gender: String
  id: String
  lastName: String
  middleName: String
  nationality: String
  phoneNumber: String
  photo: String
  updatedAt: DateTime
  userId: String
}

input ContestantMinOrderByAggregateInput {
  age: SortOrder
  birthDate: SortOrder
  createdAt: SortOrder
  email: SortOrder
  eventId: SortOrder
  firstName: SortOrder
  gender: SortOrder
  id: SortOrder
  lastName: SortOrder
  middleName: SortOrder
  nationality: SortOrder
  phoneNumber: SortOrder
  photo: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input ContestantOrderByRelationAggregateInput {
  _count: SortOrder
}

input ContestantOrderByWithAggregationInput {
  _avg: ContestantAvgOrderByAggregateInput
  _count: ContestantCountOrderByAggregateInput
  _max: ContestantMaxOrderByAggregateInput
  _min: ContestantMinOrderByAggregateInput
  _sum: ContestantSumOrderByAggregateInput
  age: SortOrder
  birthDate: SortOrder
  createdAt: SortOrder
  email: SortOrder
  eventId: SortOrder
  firstName: SortOrder
  gender: SortOrder
  id: SortOrder
  lastName: SortOrder
  middleName: SortOrder
  nationality: SortOrder
  phoneNumber: SortOrder
  photo: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input ContestantOrderByWithRelationInput {
  age: SortOrder
  birthDate: SortOrder
  createdAt: SortOrder
  email: SortOrder
  event: EventOrderByWithRelationInput
  eventId: SortOrder
  firstName: SortOrder
  gender: SortOrder
  id: SortOrder
  lastName: SortOrder
  middleName: SortOrder
  nationality: SortOrder
  phoneNumber: SortOrder
  photo: SortOrder
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

enum ContestantScalarFieldEnum {
  age
  birthDate
  createdAt
  email
  eventId
  firstName
  gender
  id
  lastName
  middleName
  nationality
  phoneNumber
  photo
  updatedAt
  userId
}

input ContestantScalarWhereInput {
  AND: [ContestantScalarWhereInput!]
  NOT: [ContestantScalarWhereInput!]
  OR: [ContestantScalarWhereInput!]
  age: IntFilter
  birthDate: StringNullableFilter
  createdAt: DateTimeNullableFilter
  email: StringFilter
  eventId: StringFilter
  firstName: StringFilter
  gender: StringFilter
  id: StringFilter
  lastName: StringFilter
  middleName: StringNullableFilter
  nationality: StringNullableFilter
  phoneNumber: StringFilter
  photo: StringNullableFilter
  updatedAt: DateTimeNullableFilter
  userId: StringFilter
}

input ContestantScalarWhereWithAggregatesInput {
  AND: [ContestantScalarWhereWithAggregatesInput!]
  NOT: [ContestantScalarWhereWithAggregatesInput!]
  OR: [ContestantScalarWhereWithAggregatesInput!]
  age: IntWithAggregatesFilter
  birthDate: StringNullableWithAggregatesFilter
  createdAt: DateTimeNullableWithAggregatesFilter
  email: StringWithAggregatesFilter
  eventId: StringWithAggregatesFilter
  firstName: StringWithAggregatesFilter
  gender: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  lastName: StringWithAggregatesFilter
  middleName: StringNullableWithAggregatesFilter
  nationality: StringNullableWithAggregatesFilter
  phoneNumber: StringWithAggregatesFilter
  photo: StringNullableWithAggregatesFilter
  updatedAt: DateTimeNullableWithAggregatesFilter
  userId: StringWithAggregatesFilter
}

type ContestantSumAggregate {
  age: Int
}

input ContestantSumOrderByAggregateInput {
  age: SortOrder
}

input ContestantUpdateInput {
  age: IntFieldUpdateOperationsInput
  birthDate: NullableStringFieldUpdateOperationsInput
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  event: EventUpdateOneRequiredWithoutContestantsNestedInput
  firstName: StringFieldUpdateOperationsInput
  gender: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  middleName: NullableStringFieldUpdateOperationsInput
  nationality: NullableStringFieldUpdateOperationsInput
  phoneNumber: StringFieldUpdateOperationsInput
  photo: NullableStringFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutContestantNestedInput
}

input ContestantUpdateManyMutationInput {
  age: IntFieldUpdateOperationsInput
  birthDate: NullableStringFieldUpdateOperationsInput
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  gender: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  middleName: NullableStringFieldUpdateOperationsInput
  nationality: NullableStringFieldUpdateOperationsInput
  phoneNumber: StringFieldUpdateOperationsInput
  photo: NullableStringFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input ContestantUpdateManyWithWhereWithoutEventInput {
  data: ContestantUpdateManyMutationInput!
  where: ContestantScalarWhereInput!
}

input ContestantUpdateManyWithWhereWithoutUserInput {
  data: ContestantUpdateManyMutationInput!
  where: ContestantScalarWhereInput!
}

input ContestantUpdateManyWithoutEventNestedInput {
  connect: [ContestantWhereUniqueInput!]
  connectOrCreate: [ContestantCreateOrConnectWithoutEventInput!]
  create: [ContestantCreateWithoutEventInput!]
  createMany: ContestantCreateManyEventInputEnvelope
  delete: [ContestantWhereUniqueInput!]
  deleteMany: [ContestantScalarWhereInput!]
  disconnect: [ContestantWhereUniqueInput!]
  set: [ContestantWhereUniqueInput!]
  update: [ContestantUpdateWithWhereUniqueWithoutEventInput!]
  updateMany: [ContestantUpdateManyWithWhereWithoutEventInput!]
  upsert: [ContestantUpsertWithWhereUniqueWithoutEventInput!]
}

input ContestantUpdateManyWithoutUserNestedInput {
  connect: [ContestantWhereUniqueInput!]
  connectOrCreate: [ContestantCreateOrConnectWithoutUserInput!]
  create: [ContestantCreateWithoutUserInput!]
  createMany: ContestantCreateManyUserInputEnvelope
  delete: [ContestantWhereUniqueInput!]
  deleteMany: [ContestantScalarWhereInput!]
  disconnect: [ContestantWhereUniqueInput!]
  set: [ContestantWhereUniqueInput!]
  update: [ContestantUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [ContestantUpdateManyWithWhereWithoutUserInput!]
  upsert: [ContestantUpsertWithWhereUniqueWithoutUserInput!]
}

input ContestantUpdateWithWhereUniqueWithoutEventInput {
  data: ContestantUpdateWithoutEventInput!
  where: ContestantWhereUniqueInput!
}

input ContestantUpdateWithWhereUniqueWithoutUserInput {
  data: ContestantUpdateWithoutUserInput!
  where: ContestantWhereUniqueInput!
}

input ContestantUpdateWithoutEventInput {
  age: IntFieldUpdateOperationsInput
  birthDate: NullableStringFieldUpdateOperationsInput
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  gender: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  middleName: NullableStringFieldUpdateOperationsInput
  nationality: NullableStringFieldUpdateOperationsInput
  phoneNumber: StringFieldUpdateOperationsInput
  photo: NullableStringFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutContestantNestedInput
}

input ContestantUpdateWithoutUserInput {
  age: IntFieldUpdateOperationsInput
  birthDate: NullableStringFieldUpdateOperationsInput
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  event: EventUpdateOneRequiredWithoutContestantsNestedInput
  firstName: StringFieldUpdateOperationsInput
  gender: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  middleName: NullableStringFieldUpdateOperationsInput
  nationality: NullableStringFieldUpdateOperationsInput
  phoneNumber: StringFieldUpdateOperationsInput
  photo: NullableStringFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input ContestantUpsertWithWhereUniqueWithoutEventInput {
  create: ContestantCreateWithoutEventInput!
  update: ContestantUpdateWithoutEventInput!
  where: ContestantWhereUniqueInput!
}

input ContestantUpsertWithWhereUniqueWithoutUserInput {
  create: ContestantCreateWithoutUserInput!
  update: ContestantUpdateWithoutUserInput!
  where: ContestantWhereUniqueInput!
}

input ContestantWhereInput {
  AND: [ContestantWhereInput!]
  NOT: [ContestantWhereInput!]
  OR: [ContestantWhereInput!]
  age: IntFilter
  birthDate: StringNullableFilter
  createdAt: DateTimeNullableFilter
  email: StringFilter
  event: EventRelationFilter
  eventId: StringFilter
  firstName: StringFilter
  gender: StringFilter
  id: StringFilter
  lastName: StringFilter
  middleName: StringNullableFilter
  nationality: StringNullableFilter
  phoneNumber: StringFilter
  photo: StringNullableFilter
  updatedAt: DateTimeNullableFilter
  user: UserRelationFilter
  userId: StringFilter
}

input ContestantWhereUniqueInput {
  id: String
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input DateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input EnumUserRoleFieldUpdateOperationsInput {
  set: UserRole
}

input EnumUserRoleFilter {
  equals: UserRole
  in: [UserRole!]
  not: NestedEnumUserRoleFilter
  notIn: [UserRole!]
}

input EnumUserRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumUserRoleFilter
  _min: NestedEnumUserRoleFilter
  equals: UserRole
  in: [UserRole!]
  not: NestedEnumUserRoleWithAggregatesFilter
  notIn: [UserRole!]
}

type Event {
  _count: EventCount
  banner: String
  category: String!
  contestants(
    cursor: ContestantWhereUniqueInput
    distinct: [ContestantScalarFieldEnum!]
    orderBy: [ContestantOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: ContestantWhereInput
  ): [Contestant!]!
  createdAt: DateTime
  description: String!
  eventEnds: DateTime
  eventStarts: DateTime
  id: String!
  name: String!
  organizer: String!
  slug: String
  tags: String
  type: String
  updatedAt: DateTime
  user: User!
  userId: String!
}

type EventCount {
  contestants: Int!
}

type EventCountAggregate {
  _all: Int!
  banner: Int!
  category: Int!
  createdAt: Int!
  description: Int!
  eventEnds: Int!
  eventStarts: Int!
  id: Int!
  name: Int!
  organizer: Int!
  slug: Int!
  tags: Int!
  type: Int!
  updatedAt: Int!
  userId: Int!
}

input EventCountOrderByAggregateInput {
  banner: SortOrder
  category: SortOrder
  createdAt: SortOrder
  description: SortOrder
  eventEnds: SortOrder
  eventStarts: SortOrder
  id: SortOrder
  name: SortOrder
  organizer: SortOrder
  slug: SortOrder
  tags: SortOrder
  type: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input EventCreateInput {
  banner: String
  category: String!
  contestants: ContestantCreateNestedManyWithoutEventInput
  createdAt: DateTime
  description: String!
  eventEnds: DateTime
  eventStarts: DateTime
  id: String
  name: String!
  organizer: String!
  slug: String
  tags: String
  type: String
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutEventsInput!
}

input EventCreateManyInput {
  banner: String
  category: String!
  createdAt: DateTime
  description: String!
  eventEnds: DateTime
  eventStarts: DateTime
  id: String
  name: String!
  organizer: String!
  slug: String
  tags: String
  type: String
  updatedAt: DateTime
  userId: String!
}

input EventCreateManyUserInput {
  banner: String
  category: String!
  createdAt: DateTime
  description: String!
  eventEnds: DateTime
  eventStarts: DateTime
  id: String
  name: String!
  organizer: String!
  slug: String
  tags: String
  type: String
  updatedAt: DateTime
}

input EventCreateManyUserInputEnvelope {
  data: [EventCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input EventCreateNestedManyWithoutUserInput {
  connect: [EventWhereUniqueInput!]
  connectOrCreate: [EventCreateOrConnectWithoutUserInput!]
  create: [EventCreateWithoutUserInput!]
  createMany: EventCreateManyUserInputEnvelope
}

input EventCreateNestedOneWithoutContestantsInput {
  connect: EventWhereUniqueInput
  connectOrCreate: EventCreateOrConnectWithoutContestantsInput
  create: EventCreateWithoutContestantsInput
}

input EventCreateOrConnectWithoutContestantsInput {
  create: EventCreateWithoutContestantsInput!
  where: EventWhereUniqueInput!
}

input EventCreateOrConnectWithoutUserInput {
  create: EventCreateWithoutUserInput!
  where: EventWhereUniqueInput!
}

input EventCreateWithoutContestantsInput {
  banner: String
  category: String!
  createdAt: DateTime
  description: String!
  eventEnds: DateTime
  eventStarts: DateTime
  id: String
  name: String!
  organizer: String!
  slug: String
  tags: String
  type: String
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutEventsInput!
}

input EventCreateWithoutUserInput {
  banner: String
  category: String!
  contestants: ContestantCreateNestedManyWithoutEventInput
  createdAt: DateTime
  description: String!
  eventEnds: DateTime
  eventStarts: DateTime
  id: String
  name: String!
  organizer: String!
  slug: String
  tags: String
  type: String
  updatedAt: DateTime
}

type EventGroupBy {
  _count: EventCountAggregate
  _max: EventMaxAggregate
  _min: EventMinAggregate
  banner: String
  category: String!
  createdAt: DateTime
  description: String!
  eventEnds: DateTime
  eventStarts: DateTime
  id: String!
  name: String!
  organizer: String!
  slug: String
  tags: String
  type: String
  updatedAt: DateTime
  userId: String!
}

input EventListRelationFilter {
  every: EventWhereInput
  none: EventWhereInput
  some: EventWhereInput
}

type EventMaxAggregate {
  banner: String
  category: String
  createdAt: DateTime
  description: String
  eventEnds: DateTime
  eventStarts: DateTime
  id: String
  name: String
  organizer: String
  slug: String
  tags: String
  type: String
  updatedAt: DateTime
  userId: String
}

input EventMaxOrderByAggregateInput {
  banner: SortOrder
  category: SortOrder
  createdAt: SortOrder
  description: SortOrder
  eventEnds: SortOrder
  eventStarts: SortOrder
  id: SortOrder
  name: SortOrder
  organizer: SortOrder
  slug: SortOrder
  tags: SortOrder
  type: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

type EventMinAggregate {
  banner: String
  category: String
  createdAt: DateTime
  description: String
  eventEnds: DateTime
  eventStarts: DateTime
  id: String
  name: String
  organizer: String
  slug: String
  tags: String
  type: String
  updatedAt: DateTime
  userId: String
}

input EventMinOrderByAggregateInput {
  banner: SortOrder
  category: SortOrder
  createdAt: SortOrder
  description: SortOrder
  eventEnds: SortOrder
  eventStarts: SortOrder
  id: SortOrder
  name: SortOrder
  organizer: SortOrder
  slug: SortOrder
  tags: SortOrder
  type: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input EventOrderByRelationAggregateInput {
  _count: SortOrder
}

input EventOrderByWithAggregationInput {
  _count: EventCountOrderByAggregateInput
  _max: EventMaxOrderByAggregateInput
  _min: EventMinOrderByAggregateInput
  banner: SortOrder
  category: SortOrder
  createdAt: SortOrder
  description: SortOrder
  eventEnds: SortOrder
  eventStarts: SortOrder
  id: SortOrder
  name: SortOrder
  organizer: SortOrder
  slug: SortOrder
  tags: SortOrder
  type: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input EventOrderByWithRelationInput {
  banner: SortOrder
  category: SortOrder
  contestants: ContestantOrderByRelationAggregateInput
  createdAt: SortOrder
  description: SortOrder
  eventEnds: SortOrder
  eventStarts: SortOrder
  id: SortOrder
  name: SortOrder
  organizer: SortOrder
  slug: SortOrder
  tags: SortOrder
  type: SortOrder
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

input EventRelationFilter {
  is: EventWhereInput
  isNot: EventWhereInput
}

enum EventScalarFieldEnum {
  banner
  category
  createdAt
  description
  eventEnds
  eventStarts
  id
  name
  organizer
  slug
  tags
  type
  updatedAt
  userId
}

input EventScalarWhereInput {
  AND: [EventScalarWhereInput!]
  NOT: [EventScalarWhereInput!]
  OR: [EventScalarWhereInput!]
  banner: StringNullableFilter
  category: StringFilter
  createdAt: DateTimeNullableFilter
  description: StringFilter
  eventEnds: DateTimeNullableFilter
  eventStarts: DateTimeNullableFilter
  id: StringFilter
  name: StringFilter
  organizer: StringFilter
  slug: StringNullableFilter
  tags: StringNullableFilter
  type: StringNullableFilter
  updatedAt: DateTimeNullableFilter
  userId: StringFilter
}

input EventScalarWhereWithAggregatesInput {
  AND: [EventScalarWhereWithAggregatesInput!]
  NOT: [EventScalarWhereWithAggregatesInput!]
  OR: [EventScalarWhereWithAggregatesInput!]
  banner: StringNullableWithAggregatesFilter
  category: StringWithAggregatesFilter
  createdAt: DateTimeNullableWithAggregatesFilter
  description: StringWithAggregatesFilter
  eventEnds: DateTimeNullableWithAggregatesFilter
  eventStarts: DateTimeNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  organizer: StringWithAggregatesFilter
  slug: StringNullableWithAggregatesFilter
  tags: StringNullableWithAggregatesFilter
  type: StringNullableWithAggregatesFilter
  updatedAt: DateTimeNullableWithAggregatesFilter
  userId: StringWithAggregatesFilter
}

input EventUpdateInput {
  banner: NullableStringFieldUpdateOperationsInput
  category: StringFieldUpdateOperationsInput
  contestants: ContestantUpdateManyWithoutEventNestedInput
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  eventEnds: NullableDateTimeFieldUpdateOperationsInput
  eventStarts: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  organizer: StringFieldUpdateOperationsInput
  slug: NullableStringFieldUpdateOperationsInput
  tags: NullableStringFieldUpdateOperationsInput
  type: NullableStringFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutEventsNestedInput
}

input EventUpdateManyMutationInput {
  banner: NullableStringFieldUpdateOperationsInput
  category: StringFieldUpdateOperationsInput
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  eventEnds: NullableDateTimeFieldUpdateOperationsInput
  eventStarts: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  organizer: StringFieldUpdateOperationsInput
  slug: NullableStringFieldUpdateOperationsInput
  tags: NullableStringFieldUpdateOperationsInput
  type: NullableStringFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input EventUpdateManyWithWhereWithoutUserInput {
  data: EventUpdateManyMutationInput!
  where: EventScalarWhereInput!
}

input EventUpdateManyWithoutUserNestedInput {
  connect: [EventWhereUniqueInput!]
  connectOrCreate: [EventCreateOrConnectWithoutUserInput!]
  create: [EventCreateWithoutUserInput!]
  createMany: EventCreateManyUserInputEnvelope
  delete: [EventWhereUniqueInput!]
  deleteMany: [EventScalarWhereInput!]
  disconnect: [EventWhereUniqueInput!]
  set: [EventWhereUniqueInput!]
  update: [EventUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [EventUpdateManyWithWhereWithoutUserInput!]
  upsert: [EventUpsertWithWhereUniqueWithoutUserInput!]
}

input EventUpdateOneRequiredWithoutContestantsNestedInput {
  connect: EventWhereUniqueInput
  connectOrCreate: EventCreateOrConnectWithoutContestantsInput
  create: EventCreateWithoutContestantsInput
  update: EventUpdateWithoutContestantsInput
  upsert: EventUpsertWithoutContestantsInput
}

input EventUpdateWithWhereUniqueWithoutUserInput {
  data: EventUpdateWithoutUserInput!
  where: EventWhereUniqueInput!
}

input EventUpdateWithoutContestantsInput {
  banner: NullableStringFieldUpdateOperationsInput
  category: StringFieldUpdateOperationsInput
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  eventEnds: NullableDateTimeFieldUpdateOperationsInput
  eventStarts: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  organizer: StringFieldUpdateOperationsInput
  slug: NullableStringFieldUpdateOperationsInput
  tags: NullableStringFieldUpdateOperationsInput
  type: NullableStringFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutEventsNestedInput
}

input EventUpdateWithoutUserInput {
  banner: NullableStringFieldUpdateOperationsInput
  category: StringFieldUpdateOperationsInput
  contestants: ContestantUpdateManyWithoutEventNestedInput
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  eventEnds: NullableDateTimeFieldUpdateOperationsInput
  eventStarts: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  organizer: StringFieldUpdateOperationsInput
  slug: NullableStringFieldUpdateOperationsInput
  tags: NullableStringFieldUpdateOperationsInput
  type: NullableStringFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input EventUpsertWithWhereUniqueWithoutUserInput {
  create: EventCreateWithoutUserInput!
  update: EventUpdateWithoutUserInput!
  where: EventWhereUniqueInput!
}

input EventUpsertWithoutContestantsInput {
  create: EventCreateWithoutContestantsInput!
  update: EventUpdateWithoutContestantsInput!
}

input EventWhereInput {
  AND: [EventWhereInput!]
  NOT: [EventWhereInput!]
  OR: [EventWhereInput!]
  banner: StringNullableFilter
  category: StringFilter
  contestants: ContestantListRelationFilter
  createdAt: DateTimeNullableFilter
  description: StringFilter
  eventEnds: DateTimeNullableFilter
  eventStarts: DateTimeNullableFilter
  id: StringFilter
  name: StringFilter
  organizer: StringFilter
  slug: StringNullableFilter
  tags: StringNullableFilter
  type: StringNullableFilter
  updatedAt: DateTimeNullableFilter
  user: UserRelationFilter
  userId: StringFilter
}

input EventWhereUniqueInput {
  id: String
  slug: String
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Mutation {
  createManyAccount(
    data: [AccountCreateManyInput!]!
    skipDuplicates: Boolean
  ): AffectedRowsOutput!
  createManyContestant(
    data: [ContestantCreateManyInput!]!
    skipDuplicates: Boolean
  ): AffectedRowsOutput!
  createManyEvent(
    data: [EventCreateManyInput!]!
    skipDuplicates: Boolean
  ): AffectedRowsOutput!
  createManySession(
    data: [SessionCreateManyInput!]!
    skipDuplicates: Boolean
  ): AffectedRowsOutput!
  createManyUser(
    data: [UserCreateManyInput!]!
    skipDuplicates: Boolean
  ): AffectedRowsOutput!
  createManyVerificationToken(
    data: [VerificationTokenCreateManyInput!]!
    skipDuplicates: Boolean
  ): AffectedRowsOutput!
  createOneAccount(data: AccountCreateInput!): Account!
  createOneContestant(data: ContestantCreateInput!): Contestant!
  createOneEvent(data: EventCreateInput!): Event!
  createOneSession(data: SessionCreateInput!): Session!
  createOneUser(data: UserCreateInput!): User!
  createOneVerificationToken(
    data: VerificationTokenCreateInput!
  ): VerificationToken!
  deleteManyAccount(where: AccountWhereInput): AffectedRowsOutput!
  deleteManyContestant(where: ContestantWhereInput): AffectedRowsOutput!
  deleteManyEvent(where: EventWhereInput): AffectedRowsOutput!
  deleteManySession(where: SessionWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteManyVerificationToken(
    where: VerificationTokenWhereInput
  ): AffectedRowsOutput!
  deleteOneAccount(where: AccountWhereUniqueInput!): Account
  deleteOneContestant(where: ContestantWhereUniqueInput!): Contestant
  deleteOneEvent(where: EventWhereUniqueInput!): Event
  deleteOneSession(where: SessionWhereUniqueInput!): Session
  deleteOneUser(where: UserWhereUniqueInput!): User
  deleteOneVerificationToken(
    where: VerificationTokenWhereUniqueInput!
  ): VerificationToken
  updateManyAccount(
    data: AccountUpdateManyMutationInput!
    where: AccountWhereInput
  ): AffectedRowsOutput!
  updateManyContestant(
    data: ContestantUpdateManyMutationInput!
    where: ContestantWhereInput
  ): AffectedRowsOutput!
  updateManyEvent(
    data: EventUpdateManyMutationInput!
    where: EventWhereInput
  ): AffectedRowsOutput!
  updateManySession(
    data: SessionUpdateManyMutationInput!
    where: SessionWhereInput
  ): AffectedRowsOutput!
  updateManyUser(
    data: UserUpdateManyMutationInput!
    where: UserWhereInput
  ): AffectedRowsOutput!
  updateManyVerificationToken(
    data: VerificationTokenUpdateManyMutationInput!
    where: VerificationTokenWhereInput
  ): AffectedRowsOutput!
  updateOneAccount(
    data: AccountUpdateInput!
    where: AccountWhereUniqueInput!
  ): Account
  updateOneContestant(
    data: ContestantUpdateInput!
    where: ContestantWhereUniqueInput!
  ): Contestant
  updateOneEvent(data: EventUpdateInput!, where: EventWhereUniqueInput!): Event
  updateOneSession(
    data: SessionUpdateInput!
    where: SessionWhereUniqueInput!
  ): Session
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateOneVerificationToken(
    data: VerificationTokenUpdateInput!
    where: VerificationTokenWhereUniqueInput!
  ): VerificationToken
  upsertOneAccount(
    create: AccountCreateInput!
    update: AccountUpdateInput!
    where: AccountWhereUniqueInput!
  ): Account!
  upsertOneContestant(
    create: ContestantCreateInput!
    update: ContestantUpdateInput!
    where: ContestantWhereUniqueInput!
  ): Contestant!
  upsertOneEvent(
    create: EventCreateInput!
    update: EventUpdateInput!
    where: EventWhereUniqueInput!
  ): Event!
  upsertOneSession(
    create: SessionCreateInput!
    update: SessionUpdateInput!
    where: SessionWhereUniqueInput!
  ): Session!
  upsertOneUser(
    create: UserCreateInput!
    update: UserUpdateInput!
    where: UserWhereUniqueInput!
  ): User!
  upsertOneVerificationToken(
    create: VerificationTokenCreateInput!
    update: VerificationTokenUpdateInput!
    where: VerificationTokenWhereUniqueInput!
  ): VerificationToken!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedEnumUserRoleFilter {
  equals: UserRole
  in: [UserRole!]
  not: NestedEnumUserRoleFilter
  notIn: [UserRole!]
}

input NestedEnumUserRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumUserRoleFilter
  _min: NestedEnumUserRoleFilter
  equals: UserRole
  in: [UserRole!]
  not: NestedEnumUserRoleWithAggregatesFilter
  notIn: [UserRole!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input NullableIntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Query {
  account(where: AccountWhereUniqueInput!): Account
  accounts(
    cursor: AccountWhereUniqueInput
    distinct: [AccountScalarFieldEnum!]
    orderBy: [AccountOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: AccountWhereInput
  ): [Account!]!
  aggregateAccount(
    cursor: AccountWhereUniqueInput
    orderBy: [AccountOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: AccountWhereInput
  ): AggregateAccount!
  aggregateContestant(
    cursor: ContestantWhereUniqueInput
    orderBy: [ContestantOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: ContestantWhereInput
  ): AggregateContestant!
  aggregateEvent(
    cursor: EventWhereUniqueInput
    orderBy: [EventOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: EventWhereInput
  ): AggregateEvent!
  aggregateSession(
    cursor: SessionWhereUniqueInput
    orderBy: [SessionOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: SessionWhereInput
  ): AggregateSession!
  aggregateUser(
    cursor: UserWhereUniqueInput
    orderBy: [UserOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: UserWhereInput
  ): AggregateUser!
  aggregateVerificationToken(
    cursor: VerificationTokenWhereUniqueInput
    orderBy: [VerificationTokenOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: VerificationTokenWhereInput
  ): AggregateVerificationToken!
  contestant(where: ContestantWhereUniqueInput!): Contestant
  contestants(
    cursor: ContestantWhereUniqueInput
    distinct: [ContestantScalarFieldEnum!]
    orderBy: [ContestantOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: ContestantWhereInput
  ): [Contestant!]!
  event(where: EventWhereUniqueInput!): Event
  events(
    cursor: EventWhereUniqueInput
    distinct: [EventScalarFieldEnum!]
    orderBy: [EventOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: EventWhereInput
  ): [Event!]!
  findFirstAccount(
    cursor: AccountWhereUniqueInput
    distinct: [AccountScalarFieldEnum!]
    orderBy: [AccountOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: AccountWhereInput
  ): Account
  findFirstAccountOrThrow(
    cursor: AccountWhereUniqueInput
    distinct: [AccountScalarFieldEnum!]
    orderBy: [AccountOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: AccountWhereInput
  ): Account
  findFirstContestant(
    cursor: ContestantWhereUniqueInput
    distinct: [ContestantScalarFieldEnum!]
    orderBy: [ContestantOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: ContestantWhereInput
  ): Contestant
  findFirstContestantOrThrow(
    cursor: ContestantWhereUniqueInput
    distinct: [ContestantScalarFieldEnum!]
    orderBy: [ContestantOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: ContestantWhereInput
  ): Contestant
  findFirstEvent(
    cursor: EventWhereUniqueInput
    distinct: [EventScalarFieldEnum!]
    orderBy: [EventOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: EventWhereInput
  ): Event
  findFirstEventOrThrow(
    cursor: EventWhereUniqueInput
    distinct: [EventScalarFieldEnum!]
    orderBy: [EventOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: EventWhereInput
  ): Event
  findFirstSession(
    cursor: SessionWhereUniqueInput
    distinct: [SessionScalarFieldEnum!]
    orderBy: [SessionOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: SessionWhereInput
  ): Session
  findFirstSessionOrThrow(
    cursor: SessionWhereUniqueInput
    distinct: [SessionScalarFieldEnum!]
    orderBy: [SessionOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: SessionWhereInput
  ): Session
  findFirstUser(
    cursor: UserWhereUniqueInput
    distinct: [UserScalarFieldEnum!]
    orderBy: [UserOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: UserWhereInput
  ): User
  findFirstUserOrThrow(
    cursor: UserWhereUniqueInput
    distinct: [UserScalarFieldEnum!]
    orderBy: [UserOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: UserWhereInput
  ): User
  findFirstVerificationToken(
    cursor: VerificationTokenWhereUniqueInput
    distinct: [VerificationTokenScalarFieldEnum!]
    orderBy: [VerificationTokenOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: VerificationTokenWhereInput
  ): VerificationToken
  findFirstVerificationTokenOrThrow(
    cursor: VerificationTokenWhereUniqueInput
    distinct: [VerificationTokenScalarFieldEnum!]
    orderBy: [VerificationTokenOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: VerificationTokenWhereInput
  ): VerificationToken
  getAccount(where: AccountWhereUniqueInput!): Account
  getContestant(where: ContestantWhereUniqueInput!): Contestant
  getEvent(where: EventWhereUniqueInput!): Event
  getSession(where: SessionWhereUniqueInput!): Session
  getUser(where: UserWhereUniqueInput!): User
  getVerificationToken(
    where: VerificationTokenWhereUniqueInput!
  ): VerificationToken
  groupByAccount(
    by: [AccountScalarFieldEnum!]!
    having: AccountScalarWhereWithAggregatesInput
    orderBy: [AccountOrderByWithAggregationInput!]
    skip: Int
    take: Int
    where: AccountWhereInput
  ): [AccountGroupBy!]!
  groupByContestant(
    by: [ContestantScalarFieldEnum!]!
    having: ContestantScalarWhereWithAggregatesInput
    orderBy: [ContestantOrderByWithAggregationInput!]
    skip: Int
    take: Int
    where: ContestantWhereInput
  ): [ContestantGroupBy!]!
  groupByEvent(
    by: [EventScalarFieldEnum!]!
    having: EventScalarWhereWithAggregatesInput
    orderBy: [EventOrderByWithAggregationInput!]
    skip: Int
    take: Int
    where: EventWhereInput
  ): [EventGroupBy!]!
  groupBySession(
    by: [SessionScalarFieldEnum!]!
    having: SessionScalarWhereWithAggregatesInput
    orderBy: [SessionOrderByWithAggregationInput!]
    skip: Int
    take: Int
    where: SessionWhereInput
  ): [SessionGroupBy!]!
  groupByUser(
    by: [UserScalarFieldEnum!]!
    having: UserScalarWhereWithAggregatesInput
    orderBy: [UserOrderByWithAggregationInput!]
    skip: Int
    take: Int
    where: UserWhereInput
  ): [UserGroupBy!]!
  groupByVerificationToken(
    by: [VerificationTokenScalarFieldEnum!]!
    having: VerificationTokenScalarWhereWithAggregatesInput
    orderBy: [VerificationTokenOrderByWithAggregationInput!]
    skip: Int
    take: Int
    where: VerificationTokenWhereInput
  ): [VerificationTokenGroupBy!]!
  session(where: SessionWhereUniqueInput!): Session
  sessions(
    cursor: SessionWhereUniqueInput
    distinct: [SessionScalarFieldEnum!]
    orderBy: [SessionOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: SessionWhereInput
  ): [Session!]!
  user(where: UserWhereUniqueInput!): User
  users(
    cursor: UserWhereUniqueInput
    distinct: [UserScalarFieldEnum!]
    orderBy: [UserOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: UserWhereInput
  ): [User!]!
  verificationToken(
    where: VerificationTokenWhereUniqueInput!
  ): VerificationToken
  verificationTokens(
    cursor: VerificationTokenWhereUniqueInput
    distinct: [VerificationTokenScalarFieldEnum!]
    orderBy: [VerificationTokenOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: VerificationTokenWhereInput
  ): [VerificationToken!]!
}

enum QueryMode {
  default
  insensitive
}

type Session {
  expires: DateTime!
  id: String!
  sessionToken: String!
  user: User!
  userId: String!
}

type SessionCountAggregate {
  _all: Int!
  expires: Int!
  id: Int!
  sessionToken: Int!
  userId: Int!
}

input SessionCountOrderByAggregateInput {
  expires: SortOrder
  id: SortOrder
  sessionToken: SortOrder
  userId: SortOrder
}

input SessionCreateInput {
  expires: DateTime!
  id: String
  sessionToken: String!
  user: UserCreateNestedOneWithoutSessionsInput!
}

input SessionCreateManyInput {
  expires: DateTime!
  id: String
  sessionToken: String!
  userId: String!
}

input SessionCreateManyUserInput {
  expires: DateTime!
  id: String
  sessionToken: String!
}

input SessionCreateManyUserInputEnvelope {
  data: [SessionCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input SessionCreateNestedManyWithoutUserInput {
  connect: [SessionWhereUniqueInput!]
  connectOrCreate: [SessionCreateOrConnectWithoutUserInput!]
  create: [SessionCreateWithoutUserInput!]
  createMany: SessionCreateManyUserInputEnvelope
}

input SessionCreateOrConnectWithoutUserInput {
  create: SessionCreateWithoutUserInput!
  where: SessionWhereUniqueInput!
}

input SessionCreateWithoutUserInput {
  expires: DateTime!
  id: String
  sessionToken: String!
}

type SessionGroupBy {
  _count: SessionCountAggregate
  _max: SessionMaxAggregate
  _min: SessionMinAggregate
  expires: DateTime!
  id: String!
  sessionToken: String!
  userId: String!
}

input SessionListRelationFilter {
  every: SessionWhereInput
  none: SessionWhereInput
  some: SessionWhereInput
}

type SessionMaxAggregate {
  expires: DateTime
  id: String
  sessionToken: String
  userId: String
}

input SessionMaxOrderByAggregateInput {
  expires: SortOrder
  id: SortOrder
  sessionToken: SortOrder
  userId: SortOrder
}

type SessionMinAggregate {
  expires: DateTime
  id: String
  sessionToken: String
  userId: String
}

input SessionMinOrderByAggregateInput {
  expires: SortOrder
  id: SortOrder
  sessionToken: SortOrder
  userId: SortOrder
}

input SessionOrderByRelationAggregateInput {
  _count: SortOrder
}

input SessionOrderByWithAggregationInput {
  _count: SessionCountOrderByAggregateInput
  _max: SessionMaxOrderByAggregateInput
  _min: SessionMinOrderByAggregateInput
  expires: SortOrder
  id: SortOrder
  sessionToken: SortOrder
  userId: SortOrder
}

input SessionOrderByWithRelationInput {
  expires: SortOrder
  id: SortOrder
  sessionToken: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

enum SessionScalarFieldEnum {
  expires
  id
  sessionToken
  userId
}

input SessionScalarWhereInput {
  AND: [SessionScalarWhereInput!]
  NOT: [SessionScalarWhereInput!]
  OR: [SessionScalarWhereInput!]
  expires: DateTimeFilter
  id: StringFilter
  sessionToken: StringFilter
  userId: StringFilter
}

input SessionScalarWhereWithAggregatesInput {
  AND: [SessionScalarWhereWithAggregatesInput!]
  NOT: [SessionScalarWhereWithAggregatesInput!]
  OR: [SessionScalarWhereWithAggregatesInput!]
  expires: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  sessionToken: StringWithAggregatesFilter
  userId: StringWithAggregatesFilter
}

input SessionUpdateInput {
  expires: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  sessionToken: StringFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutSessionsNestedInput
}

input SessionUpdateManyMutationInput {
  expires: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  sessionToken: StringFieldUpdateOperationsInput
}

input SessionUpdateManyWithWhereWithoutUserInput {
  data: SessionUpdateManyMutationInput!
  where: SessionScalarWhereInput!
}

input SessionUpdateManyWithoutUserNestedInput {
  connect: [SessionWhereUniqueInput!]
  connectOrCreate: [SessionCreateOrConnectWithoutUserInput!]
  create: [SessionCreateWithoutUserInput!]
  createMany: SessionCreateManyUserInputEnvelope
  delete: [SessionWhereUniqueInput!]
  deleteMany: [SessionScalarWhereInput!]
  disconnect: [SessionWhereUniqueInput!]
  set: [SessionWhereUniqueInput!]
  update: [SessionUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [SessionUpdateManyWithWhereWithoutUserInput!]
  upsert: [SessionUpsertWithWhereUniqueWithoutUserInput!]
}

input SessionUpdateWithWhereUniqueWithoutUserInput {
  data: SessionUpdateWithoutUserInput!
  where: SessionWhereUniqueInput!
}

input SessionUpdateWithoutUserInput {
  expires: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  sessionToken: StringFieldUpdateOperationsInput
}

input SessionUpsertWithWhereUniqueWithoutUserInput {
  create: SessionCreateWithoutUserInput!
  update: SessionUpdateWithoutUserInput!
  where: SessionWhereUniqueInput!
}

input SessionWhereInput {
  AND: [SessionWhereInput!]
  NOT: [SessionWhereInput!]
  OR: [SessionWhereInput!]
  expires: DateTimeFilter
  id: StringFilter
  sessionToken: StringFilter
  user: UserRelationFilter
  userId: StringFilter
}

input SessionWhereUniqueInput {
  id: String
  sessionToken: String
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type User {
  Contestant(
    cursor: ContestantWhereUniqueInput
    distinct: [ContestantScalarFieldEnum!]
    orderBy: [ContestantOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: ContestantWhereInput
  ): [Contestant!]!
  _count: UserCount
  accounts(
    cursor: AccountWhereUniqueInput
    distinct: [AccountScalarFieldEnum!]
    orderBy: [AccountOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: AccountWhereInput
  ): [Account!]!
  createdAt: DateTime
  email: String!
  emailVerified: DateTime
  events(
    cursor: EventWhereUniqueInput
    distinct: [EventScalarFieldEnum!]
    orderBy: [EventOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: EventWhereInput
  ): [Event!]!
  id: String!
  image: String
  name: String
  role: UserRole!
  sessions(
    cursor: SessionWhereUniqueInput
    distinct: [SessionScalarFieldEnum!]
    orderBy: [SessionOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: SessionWhereInput
  ): [Session!]!
  updatedAt: DateTime
}

type UserCount {
  Contestant: Int!
  accounts: Int!
  events: Int!
  sessions: Int!
}

type UserCountAggregate {
  _all: Int!
  createdAt: Int!
  email: Int!
  emailVerified: Int!
  id: Int!
  image: Int!
  name: Int!
  role: Int!
  updatedAt: Int!
}

input UserCountOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  emailVerified: SortOrder
  id: SortOrder
  image: SortOrder
  name: SortOrder
  role: SortOrder
  updatedAt: SortOrder
}

input UserCreateInput {
  Contestant: ContestantCreateNestedManyWithoutUserInput
  accounts: AccountCreateNestedManyWithoutUserInput
  createdAt: DateTime
  email: String!
  emailVerified: DateTime
  events: EventCreateNestedManyWithoutUserInput
  id: String
  image: String
  name: String
  role: UserRole
  sessions: SessionCreateNestedManyWithoutUserInput
  updatedAt: DateTime
}

input UserCreateManyInput {
  createdAt: DateTime
  email: String!
  emailVerified: DateTime
  id: String
  image: String
  name: String
  role: UserRole
  updatedAt: DateTime
}

input UserCreateNestedOneWithoutAccountsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutAccountsInput
  create: UserCreateWithoutAccountsInput
}

input UserCreateNestedOneWithoutContestantInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutContestantInput
  create: UserCreateWithoutContestantInput
}

input UserCreateNestedOneWithoutEventsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutEventsInput
  create: UserCreateWithoutEventsInput
}

input UserCreateNestedOneWithoutSessionsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutSessionsInput
  create: UserCreateWithoutSessionsInput
}

input UserCreateOrConnectWithoutAccountsInput {
  create: UserCreateWithoutAccountsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutContestantInput {
  create: UserCreateWithoutContestantInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutEventsInput {
  create: UserCreateWithoutEventsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutSessionsInput {
  create: UserCreateWithoutSessionsInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutAccountsInput {
  Contestant: ContestantCreateNestedManyWithoutUserInput
  createdAt: DateTime
  email: String!
  emailVerified: DateTime
  events: EventCreateNestedManyWithoutUserInput
  id: String
  image: String
  name: String
  role: UserRole
  sessions: SessionCreateNestedManyWithoutUserInput
  updatedAt: DateTime
}

input UserCreateWithoutContestantInput {
  accounts: AccountCreateNestedManyWithoutUserInput
  createdAt: DateTime
  email: String!
  emailVerified: DateTime
  events: EventCreateNestedManyWithoutUserInput
  id: String
  image: String
  name: String
  role: UserRole
  sessions: SessionCreateNestedManyWithoutUserInput
  updatedAt: DateTime
}

input UserCreateWithoutEventsInput {
  Contestant: ContestantCreateNestedManyWithoutUserInput
  accounts: AccountCreateNestedManyWithoutUserInput
  createdAt: DateTime
  email: String!
  emailVerified: DateTime
  id: String
  image: String
  name: String
  role: UserRole
  sessions: SessionCreateNestedManyWithoutUserInput
  updatedAt: DateTime
}

input UserCreateWithoutSessionsInput {
  Contestant: ContestantCreateNestedManyWithoutUserInput
  accounts: AccountCreateNestedManyWithoutUserInput
  createdAt: DateTime
  email: String!
  emailVerified: DateTime
  events: EventCreateNestedManyWithoutUserInput
  id: String
  image: String
  name: String
  role: UserRole
  updatedAt: DateTime
}

type UserGroupBy {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  createdAt: DateTime
  email: String!
  emailVerified: DateTime
  id: String!
  image: String
  name: String
  role: UserRole!
  updatedAt: DateTime
}

type UserMaxAggregate {
  createdAt: DateTime
  email: String
  emailVerified: DateTime
  id: String
  image: String
  name: String
  role: UserRole
  updatedAt: DateTime
}

input UserMaxOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  emailVerified: SortOrder
  id: SortOrder
  image: SortOrder
  name: SortOrder
  role: SortOrder
  updatedAt: SortOrder
}

type UserMinAggregate {
  createdAt: DateTime
  email: String
  emailVerified: DateTime
  id: String
  image: String
  name: String
  role: UserRole
  updatedAt: DateTime
}

input UserMinOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  emailVerified: SortOrder
  id: SortOrder
  image: SortOrder
  name: SortOrder
  role: SortOrder
  updatedAt: SortOrder
}

input UserOrderByWithAggregationInput {
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  createdAt: SortOrder
  email: SortOrder
  emailVerified: SortOrder
  id: SortOrder
  image: SortOrder
  name: SortOrder
  role: SortOrder
  updatedAt: SortOrder
}

input UserOrderByWithRelationInput {
  Contestant: ContestantOrderByRelationAggregateInput
  accounts: AccountOrderByRelationAggregateInput
  createdAt: SortOrder
  email: SortOrder
  emailVerified: SortOrder
  events: EventOrderByRelationAggregateInput
  id: SortOrder
  image: SortOrder
  name: SortOrder
  role: SortOrder
  sessions: SessionOrderByRelationAggregateInput
  updatedAt: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserRole {
  ADMIN
  AUDIENCE
  CONTESTANT
  JUDGE
  ORGANIZER
}

enum UserScalarFieldEnum {
  createdAt
  email
  emailVerified
  id
  image
  name
  role
  updatedAt
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  createdAt: DateTimeNullableWithAggregatesFilter
  email: StringWithAggregatesFilter
  emailVerified: DateTimeNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  image: StringNullableWithAggregatesFilter
  name: StringNullableWithAggregatesFilter
  role: EnumUserRoleWithAggregatesFilter
  updatedAt: DateTimeNullableWithAggregatesFilter
}

input UserUpdateInput {
  Contestant: ContestantUpdateManyWithoutUserNestedInput
  accounts: AccountUpdateManyWithoutUserNestedInput
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  events: EventUpdateManyWithoutUserNestedInput
  id: StringFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  role: EnumUserRoleFieldUpdateOperationsInput
  sessions: SessionUpdateManyWithoutUserNestedInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  role: EnumUserRoleFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutAccountsNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutAccountsInput
  create: UserCreateWithoutAccountsInput
  update: UserUpdateWithoutAccountsInput
  upsert: UserUpsertWithoutAccountsInput
}

input UserUpdateOneRequiredWithoutContestantNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutContestantInput
  create: UserCreateWithoutContestantInput
  update: UserUpdateWithoutContestantInput
  upsert: UserUpsertWithoutContestantInput
}

input UserUpdateOneRequiredWithoutEventsNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutEventsInput
  create: UserCreateWithoutEventsInput
  update: UserUpdateWithoutEventsInput
  upsert: UserUpsertWithoutEventsInput
}

input UserUpdateOneRequiredWithoutSessionsNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutSessionsInput
  create: UserCreateWithoutSessionsInput
  update: UserUpdateWithoutSessionsInput
  upsert: UserUpsertWithoutSessionsInput
}

input UserUpdateWithoutAccountsInput {
  Contestant: ContestantUpdateManyWithoutUserNestedInput
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  events: EventUpdateManyWithoutUserNestedInput
  id: StringFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  role: EnumUserRoleFieldUpdateOperationsInput
  sessions: SessionUpdateManyWithoutUserNestedInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input UserUpdateWithoutContestantInput {
  accounts: AccountUpdateManyWithoutUserNestedInput
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  events: EventUpdateManyWithoutUserNestedInput
  id: StringFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  role: EnumUserRoleFieldUpdateOperationsInput
  sessions: SessionUpdateManyWithoutUserNestedInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input UserUpdateWithoutEventsInput {
  Contestant: ContestantUpdateManyWithoutUserNestedInput
  accounts: AccountUpdateManyWithoutUserNestedInput
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  role: EnumUserRoleFieldUpdateOperationsInput
  sessions: SessionUpdateManyWithoutUserNestedInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input UserUpdateWithoutSessionsInput {
  Contestant: ContestantUpdateManyWithoutUserNestedInput
  accounts: AccountUpdateManyWithoutUserNestedInput
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  events: EventUpdateManyWithoutUserNestedInput
  id: StringFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  role: EnumUserRoleFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input UserUpsertWithoutAccountsInput {
  create: UserCreateWithoutAccountsInput!
  update: UserUpdateWithoutAccountsInput!
}

input UserUpsertWithoutContestantInput {
  create: UserCreateWithoutContestantInput!
  update: UserUpdateWithoutContestantInput!
}

input UserUpsertWithoutEventsInput {
  create: UserCreateWithoutEventsInput!
  update: UserUpdateWithoutEventsInput!
}

input UserUpsertWithoutSessionsInput {
  create: UserCreateWithoutSessionsInput!
  update: UserUpdateWithoutSessionsInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  Contestant: ContestantListRelationFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  accounts: AccountListRelationFilter
  createdAt: DateTimeNullableFilter
  email: StringFilter
  emailVerified: DateTimeNullableFilter
  events: EventListRelationFilter
  id: StringFilter
  image: StringNullableFilter
  name: StringNullableFilter
  role: EnumUserRoleFilter
  sessions: SessionListRelationFilter
  updatedAt: DateTimeNullableFilter
}

input UserWhereUniqueInput {
  email: String
  id: String
}

type VerificationToken {
  expires: DateTime!
  identifier: String!
  token: String!
}

type VerificationTokenCountAggregate {
  _all: Int!
  expires: Int!
  identifier: Int!
  token: Int!
}

input VerificationTokenCountOrderByAggregateInput {
  expires: SortOrder
  identifier: SortOrder
  token: SortOrder
}

input VerificationTokenCreateInput {
  expires: DateTime!
  identifier: String!
  token: String!
}

input VerificationTokenCreateManyInput {
  expires: DateTime!
  identifier: String!
  token: String!
}

type VerificationTokenGroupBy {
  _count: VerificationTokenCountAggregate
  _max: VerificationTokenMaxAggregate
  _min: VerificationTokenMinAggregate
  expires: DateTime!
  identifier: String!
  token: String!
}

input VerificationTokenIdentifierTokenCompoundUniqueInput {
  identifier: String!
  token: String!
}

type VerificationTokenMaxAggregate {
  expires: DateTime
  identifier: String
  token: String
}

input VerificationTokenMaxOrderByAggregateInput {
  expires: SortOrder
  identifier: SortOrder
  token: SortOrder
}

type VerificationTokenMinAggregate {
  expires: DateTime
  identifier: String
  token: String
}

input VerificationTokenMinOrderByAggregateInput {
  expires: SortOrder
  identifier: SortOrder
  token: SortOrder
}

input VerificationTokenOrderByWithAggregationInput {
  _count: VerificationTokenCountOrderByAggregateInput
  _max: VerificationTokenMaxOrderByAggregateInput
  _min: VerificationTokenMinOrderByAggregateInput
  expires: SortOrder
  identifier: SortOrder
  token: SortOrder
}

input VerificationTokenOrderByWithRelationInput {
  expires: SortOrder
  identifier: SortOrder
  token: SortOrder
}

enum VerificationTokenScalarFieldEnum {
  expires
  identifier
  token
}

input VerificationTokenScalarWhereWithAggregatesInput {
  AND: [VerificationTokenScalarWhereWithAggregatesInput!]
  NOT: [VerificationTokenScalarWhereWithAggregatesInput!]
  OR: [VerificationTokenScalarWhereWithAggregatesInput!]
  expires: DateTimeWithAggregatesFilter
  identifier: StringWithAggregatesFilter
  token: StringWithAggregatesFilter
}

input VerificationTokenUpdateInput {
  expires: DateTimeFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  token: StringFieldUpdateOperationsInput
}

input VerificationTokenUpdateManyMutationInput {
  expires: DateTimeFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  token: StringFieldUpdateOperationsInput
}

input VerificationTokenWhereInput {
  AND: [VerificationTokenWhereInput!]
  NOT: [VerificationTokenWhereInput!]
  OR: [VerificationTokenWhereInput!]
  expires: DateTimeFilter
  identifier: StringFilter
  token: StringFilter
}

input VerificationTokenWhereUniqueInput {
  identifier_token: VerificationTokenIdentifierTokenCompoundUniqueInput
  token: String
}
